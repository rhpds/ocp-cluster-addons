{{ if .Values.patcher -}}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ .Values.patcher.name }}
  namespace: {{ .Values.patcher.namespace }}
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded
    argocd.argoproj.io/sync-wave: "{{ .Values.patcher.syncwave }}"
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: {{ .Values.patcher.name }}
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded
    argocd.argoproj.io/sync-wave: "{{ .Values.patcher.syncwave }}"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: {{ .Values.patcher.name }}
  namespace: {{ .Values.patcher.namespace }}
{{ if eq .Values.patcher.route true -}}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Values.patcher.name }}-route-script
  namespace: {{ .Values.patcher.namespace }}
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded
    argocd.argoproj.io/sync-wave: "{{ .Values.patcher.syncwave }}"
data:
  make_route.sh: |
    #!/bin/bash
    # Script to create an OpenShift Route for the Gateway's LoadBalancer service
    # This works around the lack of real LoadBalancer in CRC environments

    # Source: https://github.com/jctanner/odh-security-2.0/blob/main/test.configs/make_route.sh

    set -e

    echo "=== Gateway LoadBalancer Route Creator ==="
    echo ""

    # Auto-discover the gateway
    echo "ğŸ” Discovering Gateway..."
    GATEWAY_INFO=$(kubectl get gateway --all-namespaces --no-headers -o custom-columns=NS:.metadata.namespace,NAME:.metadata.name | awk '$2 ~ /gateway/ {print $1"/"$2; exit}')

    if [ -z "$GATEWAY_INFO" ]; then
        echo "âŒ Error: No Gateway found in cluster"
        exit 1
    fi

    GATEWAY_NAMESPACE=$(echo "$GATEWAY_INFO" | cut -d'/' -f1)
    GATEWAY_NAME=$(echo "$GATEWAY_INFO" | cut -d'/' -f2)
    echo "âœ“ Found Gateway: $GATEWAY_NAMESPACE/$GATEWAY_NAME"

    # Get gateway UID for owner reference
    GATEWAY_UID=$(kubectl get gateway "$GATEWAY_NAME" -n "$GATEWAY_NAMESPACE" -o jsonpath='{.metadata.uid}')

    # Get gateway listener hostname
    GATEWAY_HOSTNAME=$(kubectl get gateway "$GATEWAY_NAME" -n "$GATEWAY_NAMESPACE" -o jsonpath='{.spec.listeners[?(@.name=="https")].hostname}')
    if [ -z "$GATEWAY_HOSTNAME" ]; then
        echo "âš ï¸  Warning: Could not find HTTPS listener hostname on gateway"
    fi
    echo "âœ“ Gateway hostname: $GATEWAY_HOSTNAME"

    # Find the LoadBalancer service created for the gateway
    GATEWAY_LB_SERVICE=$(kubectl get svc -n "$GATEWAY_NAMESPACE" -l "gateway.networking.k8s.io/gateway-name=$GATEWAY_NAME" -o jsonpath='{.items[0].metadata.name}')
    if [ -z "$GATEWAY_LB_SERVICE" ]; then
        echo "âŒ Error: Could not find LoadBalancer service for gateway $GATEWAY_NAME"
        exit 1
    fi
    echo "âœ“ Gateway LoadBalancer service: $GATEWAY_NAMESPACE/$GATEWAY_LB_SERVICE"

    # Get service UID for owner reference
    SERVICE_UID=$(kubectl get svc "$GATEWAY_LB_SERVICE" -n "$GATEWAY_NAMESPACE" -o jsonpath='{.metadata.uid}')

    # Check current LoadBalancer status
    EXTERNAL_ADDRESS=$(kubectl get svc "$GATEWAY_LB_SERVICE" -n "$GATEWAY_NAMESPACE" -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
    if [ -z "$EXTERNAL_ADDRESS" ]; then
        EXTERNAL_ADDRESS=$(kubectl get svc "$GATEWAY_LB_SERVICE" -n "$GATEWAY_NAMESPACE" -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
    fi

    if [ -z "$EXTERNAL_ADDRESS" ]; then
        echo "âš ï¸  LoadBalancer external address is pending (expected in CRC)"
    else
        echo "âœ“ Current external address: $EXTERNAL_ADDRESS"
    fi

    echo ""

    # Check if Route already exists
    ROUTE_NAME="gateway-lb-$GATEWAY_NAME"
    if kubectl get route "$ROUTE_NAME" -n "$GATEWAY_NAMESPACE" &>/dev/null; then
        echo "âš ï¸  Route $ROUTE_NAME already exists"
        echo "Updating existing Route..."
        ACTION="updated"
    else
        echo "ğŸ“ Creating new Route: $ROUTE_NAME"
        ACTION="created"
    fi

    # Use the gateway's hostname or generate one
    if [ -n "$GATEWAY_HOSTNAME" ]; then
        ROUTE_HOSTNAME="$GATEWAY_HOSTNAME"
    else
        ROUTE_HOSTNAME="$GATEWAY_NAME.$GATEWAY_NAMESPACE.apps-crc.testing"
    fi

    echo "Creating OpenShift Route to expose Gateway LoadBalancer..."

    # Create the Route
    kubectl apply -f - <<EOF
    apiVersion: route.openshift.io/v1
    kind: Route
    metadata:
      name: $ROUTE_NAME
      namespace: $GATEWAY_NAMESPACE
      labels:
        gateway-lb-route: "true"
        gateway.networking.k8s.io/gateway-name: $GATEWAY_NAME
      ownerReferences:
      - apiVersion: v1
        kind: Service
        name: $GATEWAY_LB_SERVICE
        uid: $SERVICE_UID
        controller: false
        blockOwnerDeletion: false
    spec:
      host: $ROUTE_HOSTNAME
      to:
        kind: Service
        name: $GATEWAY_LB_SERVICE
        weight: 100
      port:
        targetPort: 443
      tls:
        termination: passthrough
        insecureEdgeTerminationPolicy: Redirect
    EOF

    if [ $? -eq 0 ]; then
        echo ""
        echo "âœ… Successfully $ACTION Route $ROUTE_NAME"

        # Update the LoadBalancer service status with the Route hostname
        echo ""
        echo "ğŸ“ Updating LoadBalancer service status with Route hostname..."

        kubectl patch service "$GATEWAY_LB_SERVICE" -n "$GATEWAY_NAMESPACE" --subresource=status --type=merge -p="{
          \"status\": {
            \"loadBalancer\": {
              \"ingress\": [
                {
                  \"hostname\": \"$ROUTE_HOSTNAME\"
                }
              ]
            }
          }
        }" 2>/dev/null || echo "âš ï¸  Note: Unable to patch service status (may require additional permissions)"

        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ğŸ“‹ Configuration Summary"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "Gateway:              $GATEWAY_NAMESPACE/$GATEWAY_NAME"
        echo "LoadBalancer Service: $GATEWAY_LB_SERVICE"
        echo "OpenShift Route:      $ROUTE_NAME"
        echo "Hostname:             $ROUTE_HOSTNAME"
        echo ""
        echo "ğŸŒ Gateway is now accessible via:"
        echo "   https://$ROUTE_HOSTNAME"
        echo ""
        echo "âœ¨ Any HTTPRoutes attached to this Gateway will now be"
        echo "   accessible through the OpenShift Route!"
        echo ""
        echo "ğŸ“Š Check status:"
        echo "   oc get gateway,svc,route -n $GATEWAY_NAMESPACE"
        echo ""
        echo "ğŸ” View Gateway HTTPRoutes:"
        echo "   oc get httproute -A -o jsonpath='{range .items[?(@.spec.parentRefs[*].name=="'$GATEWAY_NAME'")]}{.metadata.namespace}/{.metadata.name}{"\n"}{end}'"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    else
        echo "âŒ Error: Failed to create Route"
        exit 1
    fi
---
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ .Values.patcher.name }}-route
  namespace: {{ .Values.patcher.namespace }}
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/sync-wave: "{{ .Values.patcher.syncwave }}"
spec:
  backoffLimit: 3
  template:
    spec:
      serviceAccountName: {{ .Values.patcher.name }}
      restartPolicy: Never
      volumes:
      - name: route-script
        configMap:
          name: {{ .Values.patcher.name }}-route-script
          defaultMode: 0755
      containers:
      - name: oc
        image: {{ .Values.patcher.image }}
        command: ["/bin/bash"]
        args: ["/scripts/make_route.sh"]
        volumeMounts:
        - name: route-script
          mountPath: /scripts
{{ end }}
{{ if .Values.patcher.dashboard -}}
---
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ .Values.patcher.name }}-dashboard
  namespace: {{ .Values.patcher.namespace }}
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/sync-wave: "{{ .Values.patcher.syncwave }}"
spec:
  backoffLimit: 3
  template:
    spec:
      serviceAccountName: {{ .Values.patcher.name }}
      restartPolicy: Never
      containers:
      - name: oc
        image: {{ .Values.patcher.image }}
        command: ["/bin/bash", "-c"]
        args:
        - |
          oc scale deployment rhods-dashboard --replicas={{ .Values.patcher.dashboard.replicas }} -n {{ .Values.patcher.namespace }}
          oc rollout status deployment/rhods-dashboard -n {{ .Values.patcher.namespace }} --watch=true
{{ end }}
{{ end }}
